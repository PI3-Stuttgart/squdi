#  Example Qudi configuration file.

global:
    # list of modules to load when starting
    startup: []

    # Module server configuration for accessing qudi GUI/logic/hardware modules from remote clients
    remote_modules_server:
        address: 'localhost'
        port: 12345

    # Server port for serving the active qudi module namespace locally (localhost).
    # Used by e.g. the Qudi jupyter kernel.
    namespace_server_port: 18861

    # If this flag is set (True), all arguments passed to qudi module APIs from remote
    # (jupyter notebook, qudi console, remote modules) will be wrapped and passed "per value"
    # (serialized and de-serialized). This is avoiding a lot of inconveniences with using numpy in
    # remote clients.
    # If you do not want to use this workaround and know what you are doing, you can disable this
    # feature by setting this flag to False.
    force_remote_calls_by_value: True

    # Qss stylesheet for controlling the appearance of the GUIs.
    # Absolute path or relative to qudi.artwork.styles
    stylesheet: 'qdark.qss'

    # Default root directory for measurement data storage. All eventual data sub-directories should
    # be contained within this directory. This is not enforced, just convention.
    # The fallback directory is <user home>/qudi/Data/
    # default_data_dir: C:\Users\neverhorst\qudi\Data

    # Save data to daily data sub-directories by default
    daily_data_dirs: True

gui:
    scanner_gui:
      module.Class: 'scanning.scannergui.ScannerGui'
      image_axes_padding: 0.02
      default_position_unit_prefix: null  # optional, use unit prefix characters, e.g. 'u' or 'n'
      optimizer_plot_dimensions: [2,1]
      connect:
          scanning_logic: scanning_probe_logic
          data_logic: scanning_data_logic
          optimize_logic: scanning_optimize_logic
    
    time_series_gui:
        module.Class: 'time_series.time_series_gui.TimeSeriesGui'
        use_antialias: True  # optional, set to False if you encounter performance issues
        connect:
            _time_series_logic_con: time_series_reader_logic


logic:
    scanning_probe_logic:
        module.Class: 'scanning_probe_logic.ScanningProbeLogic'
        max_history_length: 10
        max_scan_update_interval: 2
        position_update_interval: 1
        connect:
            scanner: ni_scanner

    scanning_data_logic:
        module.Class: 'scanning_data_logic.ScanningDataLogic'
        max_history_length: 10
        connect:
            scan_logic: scanning_probe_logic

    scanning_optimize_logic:
        module.Class: 'scanning_optimize_logic.ScanningOptimizeLogic'
        connect:
            scan_logic: scanning_probe_logic

    time_series_reader_logic:
        module.Class: 'time_series_reader_logic.TimeSeriesReaderLogic'
        max_frame_rate: 10  # optional (10Hz by default)
        calc_digital_freq: True  # optional (True by default)
        active_channels: ['pfi8','pfi3']
        connect:
            streamer: ni_instreamer


hardware:
    ni_scanner:
        module.Class: 'interfuse.ni_scanning_probe_interfuse.NiScanningProbeInterfuse'
        connect:
            scan_hardware: 'ni_io'
            analog_output: 'ni_ao'
        ni_channel_mapping:
            x: 'ao0'
            y: 'ao1'
            z: 'ao2'
            APD1: 'PFI8'
            APD2: 'PFI3'
            #AI0: 'ai0'
            #APD3: 'PFI10'
        position_ranges: # in m
            x: [-20e-6, 20e-6]
            y: [-20e-6, 20e-6]
            z: [-7.5e-6, 7.5e-6]
        frequency_ranges:
            x: [1, 500]
            y: [1, 500]
            z: [1, 500]
        resolution_ranges:
            x: [1, 1000]
            y: [1, 1000]
            z: [1, 1000]
        input_channel_units:
            APD1: 'c/s'
            APD2: 'c/s'
            #AI0: 'V'
            #APD2: 'c/s'
            #APD3: 'c/s'
        backwards_line_resolution: 50 # optional
        maximum_move_velocity: 400e-6 #m/s
    

    ni_io:
        module.Class: 'ni_x_series.ni_x_series_finite_sampling_io.NIXSeriesFiniteSamplingIO'
        device_name: 'Dev1'
        input_channel_units:  # optional
            PFI8: 'c/s'
            PFI3: 'c/s'
            #PFI10: 'c/s'
            #ai0: 'V'
            #ai1: 'V'
        output_channel_units:
            'ao0': 'V'
            'ao1': 'V'
            'ao2': 'V'
        #adc_voltage_ranges:
            #ai0: [-10, 10]  # optional
            #ai1: [-10, 10]  # optional
        output_voltage_ranges:
            ao0: [0, 4]
            ao1: [0, 4]
            ao2: [0, 4]
   
            
        #TODO output range, also limits need to be included in constraints
        frame_size_limits: [1, 1e9]  # optional #TODO actual HW constraint?
        output_mode: 'JUMP_LIST' #'JUMP_LIST' # optional, must be name of SamplingOutputMode
        read_write_timeout: 10  # optional
        #sample_clock_output: '/Dev1/PFI11' # optional

    ni_ao:
        module.Class: 'ni_x_series.ni_x_series_analog_output.NIXSeriesAnalogOutput'
        device_name: 'Dev1'

        setpoint_channels:
            ao0:
                unit: 'V'
                limits: [0, 4]
                keep_value: True
            ao1:
                unit: 'V'
                limits: [0, 4]
                keep_value: True
            ao2:
                unit: 'V'
                limits: [0, 4]
                keep_value: True

    
    # optional, for slow counter / timer series reader
    ni_instreamer:
        module.Class: 'ni_x_series.ni_x_series_in_streamer.NIXSeriesInStreamer'
        device_name: 'Dev1'
        digital_sources:  # optional
            - 'pfi8'
            - 'pfi3'
        # analog_sources:  # optional
        #   - 'ai0'
        #   - 'ai1'
        # external_sample_clock_source: 'PFI0'  # optional
        # external_sample_clock_frequency: 1000  # optional
        # adc_voltage_range: [-10, 10]  # optional
        max_channel_samples_buffer: 10000000  # optional
        read_write_timeout: 10  # optional