#  Example Qudi configuration file.

global:
    # list of modules to load when starting
    startup: []

    # Module server configuration for accessing qudi GUI/logic/hardware modules from remote clients
   # remote_modules_server:
   #     address: '129.69.46.82'
   #     port: 12345

    # Server port for serving the active qudi module namespace locally (localhost).
    # Used by e.g. the Qudi jupyter kernel.
    namespace_server_port: 18861

    # If this flag is set (True), all arguments passed to qudi module APIs from remote
    # (jupyter notebook, qudi console, remote modules) will be wrapped and passed "per value"
    # (serialized and de-serialized). This is avoiding f lot of inconveniences with using numpy in
    # remote clients.
    # If you do not want to use this workaround and know what you are doing, you can disable this
    # feature by setting this flag to False.
    force_remote_calls_by_value: True

    # Qss stylesheet for controlling the appearance of the GUIs.
    # Absolute path or relative to qudi.artwork.styles
    stylesheet: 'qdark.qss'

    # Default root directory for measurement data storage. All eventual data sub-directories should
    # be contained within this directory. This is not enforced, just convention.
    # The fallback directory is <user home>/qudi/Data/
    # default_data_dir: C:\Users\neverhorst\qudi\Data

    # Save data to daily data sub-directories by default
    daily_data_dirs: True

gui:
   # setup_control_gui:
   #     module.Class: 'setup_control.setup_control.SetupControlGui'
        #connect:
        #    Setup_Control_Logic: setup_control_logic_QINU

    setup_control:
        module.Class: setup_control_old.setupcontrolgui.SetupControlGUI
        connect:
            setupcontrollogic: setupcontrollogic
        options: {}

logic:
    setupcontrollogic:
        module.Class: setup_control.setup_control.SetupControlLogicQINU
        connect:
            Adwin_IO: adwin_IO
        options: {}

hardware:

    adwin_base:
        module.Class: 'jaeger_computer_technik.adwin_base.AdwinBase' #Should also contain all functions of adwin_old
    
    
    adwin_AO: #for confocal static.
        module.Class: 'jaeger_computer_technik.adwin_IO.Adwin_AO'
        options:
            device_name: 'adwin11'
            channels:
                ao0:
                    limits: [0.0, 1.0]
                    keep_value: True
                ao1:
                    limits: [0.0, 1.0]
                    keep_value: True
                ao2:
                    limits: [0.0, 1.0]
                    keep_value: True
    adwin_IO:
        module.Class: 'jaeger_computer_technik.adwin_IO.Adwin_IO'
        options:
            ports:
                digital:
                    3: 
                        name: 'green_laser'
                        IO: 'in'
        
                    0:
                        name: 'lamp'
                        IO: 'in'

                    6:
                        name: 'flip_powermeter'
                        'IO': 'in'
                
                analog:
                    5:
                        name: 'green_laser_attenuation'
            
    fastcounter_timetagger:
        module.Class: 'swabian_instruments.timetagger_fast_counter.TimeTaggerFastCounter'
        options:
            timetagger_channel_apd_0: 1
            timetagger_channel_apd_1: 2
            timetagger_channel_detect: 5
            timetagger_channel_sequence: 5
            timetagger_sum_channels: True
        connect:
            timetagger: 'tagger'
    
    tagger:
        module.Class: 'swabian_instruments.timetagger_api.TT'
        options:
            port: 12233
            hist:
                channels: [1,2, 3]
                trigger_channel: 5

            corr:
                channel_start: 2
                channel_stop: 3
            counter:
                channels: [1,2, 3]

            combiner:
                channels: [1,2]
            channels_params:
                1:
                    delay: 0
                    trigger_level: 0.3
                2:
                    delay: -30e3
                    trigger_level: 0.3
                3:
                    delay: 0
                    trigger_level: 0.3
                6: # cwave internal scanner
                    delay: 20e3
                    trigger_level: 2
                8: # cwave internal scanner
                    delay: 0
                    trigger_level: 1
    
    
    # #This is for the slow analog outputs probably. (set position, etc.)
    # adwin_ao: #copy from ni_X_series.ni_x_series_analog_output.NIXSeriesAnalogOutput'
    #     module.Class: 'jaeger_computer_technik.adwin_IO'
    #     options:
    #         device_name: 'adwin11'

    #         channels:
    #             ao0:
    #                 unit: 'V'
    #                 limits: [0, 10]
    #                 limits_LT: [0, 10]
    #                 keep_value: True
    #             ao1:
    #                 unit: 'V'
    #                 limits: [0, 10]
    #                 limits_LT: [0, 10]
    #                 keep_value: True
    #             ao2:
    #                 unit: 'V'
    #                 limits: [0, 10]
    #                 limits_LT: [0, 10]
    #                 keep_value: True

    adwin_galvo:
        module.Class: 'jaeger_computer_technik.adwin_Scanner.Adwin_Scanning_Device'
        options:
            device_name: 'adwin11'
            channels:
                ao0:
                    unit: 'V'
                    limits: [-5, 5]
                    keep_value: True
                ao1:
                    unit: 'V'
                    limits: [-5, 5]
                    keep_value: True


                ao2:
                    unit: 'V'
                    limits: [-5, 5]
                    keep_value: True
            clock:
                do7: 'scan_clock_physical_output'


    adwin_tt_io: ###C:\Users\yy3\git\squdi\src\qudi\hardware\jaeger_computer_technik\adwin_tt_io.py
        module.Class: 'jaeger_computer_technik.adwin_tt_io.AdwinSamplingIO'
        connect:
            tt: tagger
            adwin: adwin_galvo

        options:
            device_name: 'adwin11' ##for booting? - maybe not needed as it is lready in adwin_base.
            input_channel_units:  # optional
                tt_1: 'c/s'
                tt_2: 'c/s'
                tt_3: 'c/s'
                #ai0: 'V'
                #ai1: 'V'
            sum_channels: ["tt_1", "tt_2"]
            output_channel_units:
                'ao0': 'V'
                'ao1': 'V'
                'ao2': 'V'
                #'ao3': 'V'
            #adc_voltage_ranges:
                #ai0: [-10, 10]  # optional
                #ai1: [-10, 10]  # optional
            output_voltage_ranges:
                ao0: [0, 1]
                ao1: [0, 1]
                ao2: [0, 1]
                #ao3: [0, 1]
            output_voltage_ranges_LT:
                ao0: [0, 1]
                ao1: [0, 1]
                ao2: [0, 1]
                #ao3: [0, 1]
    
            
            #TODO output range, also limits need to be included in constraints
            frame_size_limits: [1, 1e9]  # optional #TODO actual HW constraint?
            output_mode: 'JUMP_LIST' #'JUMP_LIST' # optional, must be name of SamplingOutputMode
            read_write_timeout: 10  # optional
            sample_clock_output: 'do7' # optional
            tt_ni_clock_input: 'tt_4' #input of the clock for the NI card into the time tagger
            tt_falling_edge_clock_input: 'tt_4'
            #flip mirror porto 0 channel 4
    
    adwin_scanner:
        #module.Class: 'jaeger_computer_technik.adwin_base.AdwinBase'
        module.Class: 'interfuse.adwin_scanning_probe_interfuse.NiScanningProbeInterfuseBare'
        connect:
            scan_hardware: 'adwin_tt_io'
            analog_output: 'adwin_AO'
        
        options:
            ni_channel_mapping:
                z: 'ao2'
                x: 'ao0'
                y: 'ao1'
                APD1: 'tt_1'
                #APD2: 'tt_2'
                #APD3: 'tt_3'
                #AI0: 'ai0'
                #APD3: 'PFI10'
            sum_channels: ["tt_1"]#, "tt_2"]
            scan_units: 'm'
            position_ranges: # in m
                z: [-5e-6, 15e-6]
                x: [-200e-6, 200e-6]
                y: [-200e-6, 200e-6]
            frequency_ranges:
                z: [1, 300]
                x: [1, 300]
                y: [1, 300]
            resolution_ranges:
                z: [1, 1000]
                x: [1, 1000]
                y: [1, 1000]
            input_channel_units:
                APD1: 'c/s'
                #APD2: 'c/s'
                #APD3: 'c/s'
                #AI0: 'V's
                #APD2: 'c/s'
                #APD3: 'c/s'
            
            #backwards_line_resolution: 200 # optional
            maximum_move_velocity: 20e-6 #400e-6 #m/s 
            default_samples_number: 50
            max_counts: 3e7
            read_write_timeout: 10
            counting_edge_rising: True
            scanner_counter_channels: ['1','2']
                



   